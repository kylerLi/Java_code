/**
 * 
 * 	 设计模式
	 对象的来源是来自于现实世界的模型
	 难点：如何将系统合理分成对象集合
	 设计应支持变化：获得最大限度复用的关键在于对新需求和已有需求发生变化时的预见性，要求你的系统设计要能够相应地改进
	 
	以下 摘自 《设计模式-可复用面向对象软件设计基础》
	 1) 通过显式地指定一个类来创建对象 
	           在创建对象时指定类名将使你受特定实现的约束，而不是特定接口的约束。这会使未来的变化更复杂。要避免这种情况，应该间接地创建对象
		AbstractFactory("抽象工厂模式"),	FactoryMethod("工厂方法模式"),Prototype("原始模型模式")
		
	 2) 对特殊操作的依赖
	            当你为请求指定一个特殊的操作时，完成该请求的方式就固定下来了。为避免把请求代码写死，你将可以在编译时刻或运行时刻很方便地改变响应请求的方法。
	    ChainOfResponsibility("责任链模式"),  Command("命令模式")    
     3) 对硬件和软件平台的依赖 
     	外部的操作系统接口和应用编程接口 (API)在不同的软硬件,平台上是不同的。依赖于特定平台的软件将很难移植到其他平台上，甚至都很难跟上本地平
     	台的更新。所以设计系统时限制其平台相关性就很重要了。
		Abstract Factory("抽象工厂模式"),Bridge("桥梁模式")
	 4) 对对象表示或实现的依赖 
	 	知道对象怎样表示、保存、定位或实现的客户在对象发生变化时可能也需要变化。对客户隐藏这些信息能阻止连锁变化。
		Abstract Factory("抽象工厂模式"),Bridge("桥梁模式"),Memento("备忘录模式")
	 5) 算法依赖 算法在开发和复用时常常被扩展、优化和替代。依赖于某个特定算法的对象在算法发生变化时不得不变化。因此有可能发生变化的算法应该被孤立起来。
        Builder("建造者模式"),Iterator("迭代子模式"),Strategy("策略模式"),
        TemplateMethod("模板方法模式"),Visitor("访问者模式")
	 6) 紧耦合 紧耦合的类很难独立地被复用，因为它们是互相依赖的。紧耦合产生单块的系统，要改变或删掉一个类，你必须理解和改变其他许多类。
	 	这样的系统是一个很难学习、移植和维护的密集体。松散耦合提高了一个类本身被复用的可能性，并且系统更易于学习、移植、修改和扩展。
	 	设计模式使用抽象耦合和分层技术来提高系统的松散耦合性。
        AbstractFactory("抽象工厂模式"),Command("命令模式"),Facade("门面模式"),Mediator("调停者模式"),
        Observer("观察者模式"),ChainOfResponsibility("责任链模式")
     7) 通过生成子类来扩充功能 通常很难通过定义子类来定制对象。每一个新类都有固定的实现开销(初始化、终止处理等)。
     	定义子类还需要对父类有深入的了解。如，重定义一个操作可能需要重定义其他操作。一个被重定义的操作可能需要调用继承下来的操作。并且子类方法
     	会导致类爆炸，因为即使对于一个简单的扩充，你也不得不引入许多新的子类。过多使用对象组合(个人理解为为实现功能将多个对象组合在揉在一起)会使设计难于理解。
     	许多设计模式产生的设计中，你可以定义一个子类，且将它的实例和已存在实例进行组合来引入定制的功能。
        Bridge("桥梁模式"),ChainOfResponsibility("责任链模式"),Composite("合成模式"),Decorator("装饰模式"),
		Observer("观察者模式"),Strategy("策略模式")
	 8) 不能方便地对类进行修改 有时你不得不改变一个难以修改的类。也许你需要源代码而又没有(对于商业类库就有这种情况)，
	 	或者可能对类的任何改变会要求修改许多已存在的其他子类。设计模式提供在这些情况下对类进行修改的方法。
 		Adapter("适配器模式"),Decorator("装饰模式"),Visitor("访问者模式")
		
	设计模式与框架的区别
	 1) 设计模式比框架更抽象
	 2) 设计模式是比框架更小的体系机构元素
	 3) 框架比设计模式更加特例化 ,框架总是针对一个特定的应用领域
	
	
 * @author leo


 */
package com.leo.设计模式;


public enum DesignPattern{
	 AbstractFactory("抽象工厂模式"),Builder("建造者模式"),
	 FactoryMethod("工厂方法模式"),Prototype("原始模型模式"),
	 Singleton("单例模式"),Facade("门面模式"),
	 Adapter("适配器模式"),Bridge("桥梁模式"),
	 Composite("合成模式"),Decorator("装饰模式"),
	 Flyweight("享元模式"),Proxy("代理模式"),
	 Command("命令模式"),Interpreter("解释器模式"),
	 Visitor("访问者模式"),Iterator("迭代子模式"),Mediator("调停者模式"),
	 Memento("备忘录模式"),Observer("观察者模式"),State("状态模式"),
	 Strategy("策略模式"),TemplateMethod("模板方法模式"), 
	 ChainOfResponsibility("责任链模式");
	
	
	DesignPattern(String model){}
}
